### Управление адресным пространством:
##### a. Напишите программу, которая:

      i. выводит pid процесса;
      ii. ждет одну секунду;
      iii. делает exec(2) самой себя;
      iv. выводит сообщение “Hello world”
##### b. Понаблюдайте за выводом программы и содержимым соответствующего файла /proc/<pid>/maps. Объясните происходящее.

##### c. Напишите программу, которая: 
    
    i. выводит pid процесса;
    ii. ждет 10 секунд (подберите паузу чтобы успеть начать мониторить адресное пространство процесса, например, watch cat /proc/<pid>/maps);
    iii. напишите функцию, которая будет выделять на стеке массив (например, 4096 байт) и рекурсивно вызывать себя;
    iv. понаблюдайте как изменяется адресное пространство процесса (стек);
    v. напишите цикл, в котором на каждой итерации будет выделяться память на куче (подберите размер буфера сами). Используйте секундную паузу между итерациями.
    vi.понаблюдайте как изменится адресное пространство процесса (heap);
    vii. освободите занятую память.
    viii. присоедините к процессу еще один регион адресов размером в 10 страниц (используйте mmap(2) с флагом ANONYMOUS).
    ix. понаблюдайте за адресным пространством.
    x.измените права доступа к созданному региону и проверьте какая будет реакция, если их нарушить:
        1. запретите читать данные и попробуйте прочитать из региона.
        2. запретите писать и попробуйте записать.
    xi. попробуйте перехватить сигнал SIGSEGV.
    xii. отсоедините страницы с 4 по 6 в созданном вами регионе.
    xiii. понаблюдайте за адресным пространством.
##### d. Чтобы было удобнее наблюдать за адресным пространством подберите удобные паузы между операциями изменяющими его.

##### e. Объясните что происходит с адресным пространством в данной задаче.
### Самодельная куча
   ##### a. Реализуйте свою кучу над анонимным регионом адресов:
    i. присоедините анонимный регион (mmap(2));
    ii. реализуйте функцию my_malloc(), которая:
        1. принимает размер памяти в байтах;
        2. резервирует буфер запрошенного размера и возвращает указатель на его начало;
        3. при недостатке памяти возвращает NULL.
    iii. реализуйте функцию my_free(), которая: 
        1. принимает указатель на буфер, возвращенный ранее функцией my_malloc();
        2. помечает буфер свободным;
> iv. Рекомендация. Для отладки можно присоединить регион связанный с файлом. Это позволит наблюдать за состоянием вашей кучи при выделении-освобождении памяти.
