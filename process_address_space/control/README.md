### Структура адресного пространства.
##### a. Напишите программу, которая создает переменные и выводит их адреса:
    i. локальные в функции;
    ii. статические в функции;
    iii. константы в функции;
    iv. глобальные инициализированные;
    v. глобальные неинициализированные;
    vi. глобальные константы.
##### b. Сопоставьте адреса переменных с областями адресного пространства из соответствующего /proc/<pid>/maps. Объясните увиденное.
##### c. Используя утилиту nm (или readelf) определите в каких секциях находятся выделенные переменные переменные.
##### d. Напишите функцию, которая создает и инициализирует локальную переменную и возвращает ее адрес. Прокомментируйте результат и дайте оценку происходящему.
##### e. Напишите функцию, которая:
    i. выделяет на куче буфер (например, размером 100 байт);
    ii. записывает в него какую-либо фразу (например, hello world);
    iii. выводит содержимое буфера;
    iv .освобождает выделенную память;
    v. снова выводит содержимое буфера;
    vi. выделяет еще один буфер;
    vii. записывает в них какую-либо фразу (например, hello world);
    viii. выводит содержимое буфера;
    ix. перемещает указатель на середину буфера;
    x. освобождает память по этому указателю.
    xi. выводит содержимое буфера;
##### f. Прокомментируйте работу предыдущего пункта.
##### g. Заведите переменную окружения.
##### h. Добавьте в вашу программу код, который:
    i. распечатывает ее значение;
    ii. изменяет его значение;
    iii. повторно распечатывает ее значение.
##### i. Запустите вашу программу и убедитесь что переменная окружения имеет требуемое значение.
##### j. Выведите значение переменной окружения после того как ваша программа завершилась.
##### k. Объясните произошедшее.

### Управление адресным пространством:
##### a. Напишите программу, которая:

      i. выводит pid процесса;
      ii. ждет одну секунду;
      iii. делает exec(2) самой себя;
      iv. выводит сообщение “Hello world”
##### b. Понаблюдайте за выводом программы и содержимым соответствующего файла /proc/<pid>/maps. Объясните происходящее.

##### c. Напишите программу, которая: 
    
    i. выводит pid процесса;
    ii. ждет 10 секунд (подберите паузу чтобы успеть начать мониторить адресное пространство процесса, например, watch cat /proc/<pid>/maps);
    iii. напишите функцию, которая будет выделять на стеке массив (например, 4096 байт) и рекурсивно вызывать себя;
    iv. понаблюдайте как изменяется адресное пространство процесса (стек);
    v. напишите цикл, в котором на каждой итерации будет выделяться память на куче (подберите размер буфера сами). Используйте секундную паузу между итерациями.
    vi.понаблюдайте как изменится адресное пространство процесса (heap);
    vii. освободите занятую память.
    viii. присоедините к процессу еще один регион адресов размером в 10 страниц (используйте mmap(2) с флагом ANONYMOUS).
    ix. понаблюдайте за адресным пространством.
    x.измените права доступа к созданному региону и проверьте какая будет реакция, если их нарушить:
        1. запретите читать данные и попробуйте прочитать из региона.
        2. запретите писать и попробуйте записать.
    xi. попробуйте перехватить сигнал SIGSEGV.
    xii. отсоедините страницы с 4 по 6 в созданном вами регионе.
    xiii. понаблюдайте за адресным пространством.
##### d. Чтобы было удобнее наблюдать за адресным пространством подберите удобные паузы между операциями изменяющими его.

##### e. Объясните что происходит с адресным пространством в данной задаче.
### Самодельная куча
   ##### a. Реализуйте свою кучу над анонимным регионом адресов:
    i. присоедините анонимный регион (mmap(2));
    ii. реализуйте функцию my_malloc(), которая:
        1. принимает размер памяти в байтах;
        2. резервирует буфер запрошенного размера и возвращает указатель на его начало;
        3. при недостатке памяти возвращает NULL.
    iii. реализуйте функцию my_free(), которая: 
        1. принимает указатель на буфер, возвращенный ранее функцией my_malloc();
        2. помечает буфер свободным;
> iv. Рекомендация. Для отладки можно присоединить регион связанный с файлом. Это позволит наблюдать за состоянием вашей кучи при выделении-освобождении памяти.